# Examples for "get rid of exception generation points"

Дано: "миграция" описывающая изменения между версиями REST API для последующей кодогенерации роутеров.
Конкретная миграция дегларирует что в версии, в которой эта миграция будет применена далее,
указанный эндпоинт существуе (в более новой версии этот роутер удален/помечен удаленным и не доступен в рантайме)


```python
from cadwyn.structure import VersionChange, endpoint


class EnablingSettingsRoutes(VersionChange):
    description = "Enabling settings routes."

    instructions_to_migrate_to_previous_version = [
        endpoint("/v1/xxx/{id}/bbb", ["GET"]).existed,
        endpoint("/v1/xxx/{id}/bbb", ["PATCH"]).existed,
    ]
```

Здесь, по сути, функция endpoint является пользовательским интерфейсом. В библиотеке она выглядит так:

```python
def endpoint(path: str, methods: list[str], /, *, func_name: str | None = None) -> EndpointInstructionFactory:
    return EndpointInstructionFactory(path, set(methods), func_name)
```

Где EndpointInstructionFactory, это здоровенный датакласс используемый в дальнешейм в кодогенераторе:

```python
@dataclass(slots=True)
class EndpointInstructionFactory:
    endpoint_path: str
    endpoint_methods: set[str]
    endpoint_func_name: str | None

    ...
```

Проблема тут в том, что methods тут аннотированы примитивным типом list[str], хотя http методы это конечное множество, и в некоторых случаях можно опечататься в миграции и написать, например:

```
endpoint("/v1/xxx/{id}/bbb", ["PATH"]).existed
```

На что легко можно потратить минут 15-20 не видя опечатки с замыленным глазом.

Решение тут довольно простое - на уровне интерфейса нужно аннотировать methods завернутыми в Literal строками,
соответствующиме http методам:

```python
HTTPMethods = Literal['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD']
def endpoint(path: str, methods: list[HTTPMethods], /, *, func_name: str | None = None) -> EndpointInstructionFactory:
    valid_http_methods: set[HTTPMethods] = {'GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'}
    invalid_methods = set(methods) - valid_http_methods
    if invalid_methods:
        raise ValueError(f"Invalid HTTP methods: {', '.join(invalid_methods)}")
    return EndpointInstructionFactory(path, set(methods), func_name)
```

Благодаря литералу - тайпчекер будет уведомлять о неверных параметрах при описании миграции.
Но помимо этого нужно добавить проверку на валидность методов и возвращать исключение, если в methods все таки просочился невалидный метод.

делать тут кастомный класс или Enum и заворачивать в него строки - усложнение интерфейса, так мы заставим пользователя импотировать на одну сущность больше (для аннотирования).

В общем, в этом примере хотя и получается, то мы пошли по пунктру 3 (немного отошли от чистых пимитивов к простой абстракции), но по сути - закрыли огромный кусок модуля проверкой в этом интерфейсе. Да, мы генерируем исключение ТУТ, но мы не проваливаемся в модуль фреймворка, где, потенциально, ошибка может быть менее понятной при генерации исключения там.

---

Очень простой, повседневный пример с fastapi и pydantic из головы.

```python
from fastapi import FastAPI, Path
from scenarios.items import scenario as item_scenario
app = FastAPI()

@app.get("/items/{item_id}")
def do_something_with_item(item_id: int, some_query_parameter: str = None):
    item_scenario.do_something(item_id, some_query_parameter)
```

Это типовая ошибка новичка, одержимого None значениями как дефолтными. Так делать нельзя, потому что
у параметров запроса должно быть какое то дефолтное значение, которое не будет вызывать исключений внутри `do_something`, если этот параметр опционален.

если параметр должен быть обязательным, не нужно указывать дефолтное значение вообще, тогда ошибка будет возникать на уровне REST интерфейса и не просчиваться в приложение внутри:

```python
@app.get("/items/{item_id}")
def do_something_with_item(item_id: int, some_query_parameter: str):
    item_scenario.do_something(item_id, some_query_parameter)
```

# Examples for "abandon default constructors without parameters"

Я не нашел примеров в своем коде подходящих под второй пункт про дефолтные конструкторы без параметров.
Но если потеоретизировать, то в python возможны кошмарные конструкции вроде:

```python
class CoolClass:
    def __init__(self, arg1: str | None = None, arg2: int | None = None):
        self.arg1 = arg1
        self.arg2 = arg2

    def do_something(self):
        ...
```

И тут снова про дефолтные None, которые непонятно к чему могут привести внутри. Везде ли мы в методах залили лапшой, проверяющей None или не None? ужас.
Если мы и ставим дефолтное значение аргументам конструктора, то это должно быть что угодно, только не None. Но и это все еще не полностью безопасно.

Класс же без аргументов в конструкое в питоне вызывает подозрения и вопросы, если он действительно что то инициализирует и делает, да еще и сайд-эффетками, а не просто является интерфейсом или контейнером (dataclass, иницилизация роутера из библиотеки и так далее)


# Examples for "Avoid getting carried away with primitive data types"

В языке с динамической типизаций вроде Python можно действительно... увлечься... примитивами и вообще много чего кошмарного натворить.

Для себя я не мыслю программирование на Python без тайпхинтов, тайпчекеров и Pydantic моделей, если пишется что то больше, чем скрипт на ~50-150 строк кода.

Типовой и плохой пример программирования спонталыку:

```python
class Order:
    def __init__(self, order_id: int, product_name: str, price: float):
        self.order_id = order_id
        self.product_name = product_name
        self.price = price
```

Может я одержим Pydantic'ом но пример выше сходу хочется переписать так:

```python
from pydantic import BaseModel, Field
from decimal import Decimal

class Currency(BaseModel):
    code: str
    symbol: str

class Product(BaseModel):
    name: str
    price: Decimal
    currency: Currency

class Order(BaseModel):
    order_id: int
    product: Product
    quantity: int
```

Процессинг заказов можно уже выделить в отдельный класс из нормальной проектой иерархии/структуры. С помощью пайдетника мы можем отказаться вообще от всех примитивов в системе, инкапсулировав их в семантически правильный сущности в контексте домена нашей системы. Мы можем аннотировать переменные/аргументы этими
моделями и *почти* всегда это будет работать и не вызывать ошибок тайпчекера если вызывает, то в 8 из 10 случаев мы перемудрили или пытаемся ~~натянуть сову на глобус~~ внедрить модель пидантика в проектную иерархию. Хотя это и возможно, но кажется что нужно использовать пидантик по назначению и описывать им прикладную систему типов.

## Reflection (больше по пунктам 1 и 2)

Вообще, в виду природы Python нормального способа запретить дефолтный конструктор нет. Python наоборот предлагает указывать некоторые дефолтные параметры для
аругументов конструктора, но это не совсем то чего хочется добиться (или даже что всегда возможно?).

А что же делать, если мы хотим потребовать конкретное значение, конкретного типа,  для конкретного аргумента конструктора (проверка предусловия)? Кажется, что тут в принципе нет выбора, кроме как в этом самом конструкторе проверять значение этого аргумента и генерировать исключение (какой нибудь ValueError с выразительным сообщением).

А если у нас таких аргументов несколько, то конструктор визуально распухает как корытце с дошираком, залитое кипятком. Но ничего не мешает: вынести эти проверки в какой то абстрактный тип, либо инкапсулирвать в отдельный класс/метод, который будет выполнять конкретную функцию валидации и генерировать соответствующие исключения.

И это все еще решение для неправильных или отсутствующих значений для аргументов коструктора. Если у нас по какой то причине в некотором классе есть методы, которые могут поломать работу, если пользователь их вызовет... Ну, например (на плохой пример) у нас есть метод в классе, который идет в другой микросервис и вытаскивает некоторые данные из него, соответствующие сущности которую в нашем класе мы обрабатываем.

И в этом же классе у нас есть helper-метод, который уже эти вытащенные данные обрабатывает (например мы декомпозировали все это в целях выразительности и удобочитемости кода). В конструкторе нашего классе ВООБЩЕ нет данных для работы этого метода, у пользователя нашего класса их скорее всего тоже нет, он вообще не должен о них звать! Но по нелепой ошибке он может попытаться "дернуть" где то в коде этот метод и вызвать исключение. Если все это нельзя перепроектировать, не важно по какой причине, начальник-рептилоид ни за что не хочет это трогать, но начальника-рептилоида все еще можно попытаться убедить закрыть этот кошмар абстрактным типом данных. Понятно, что этот АТД изначально должен был быть спроектирован, а затем реализован некоторым классом(ами). Тогда бы у нашей буренки вообще проблем не было... С одной стороны, плохо что в питоне нет *нормальной* инкапсуляции, с другой стороны это хорошо, и заставляет делать шаг на асбтракции выше, если мы вообще заинтересованы в нормальной архитектуре.
